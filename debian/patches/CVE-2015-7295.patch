Description: fix denial of service via jumbo frame flood in virtio
Origin: upstream, http://git.qemu.org/?p=qemu.git;a=commit;h=ce317461573bac12b10d67699b4ddf1f97cf066c
Origin: upstream, http://git.qemu.org/?p=qemu.git;a=commit;h=29b9f5efd78ae0f9cc02dd169b6e80d2c404bade
Origin: upstream, http://git.qemu.org/?p=qemu.git;a=commit;h=0cf33fb6b49a19de32859e2cdc6021334f448fb3
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=799452

Index: qemu-2.0.0+dfsg/hw/net/virtio-net.c
===================================================================
--- qemu-2.0.0+dfsg.orig/hw/net/virtio-net.c	2015-12-01 16:00:51.324389271 -0500
+++ qemu-2.0.0+dfsg/hw/net/virtio-net.c	2015-12-01 16:00:51.296389018 -0500
@@ -1032,13 +1032,7 @@
          * must have consumed the complete packet.
          * Otherwise, drop it. */
         if (!n->mergeable_rx_bufs && offset < size) {
-#if 0
-            error_report("virtio-net truncated non-mergeable packet: "
-                         "i %zd mergeable %d offset %zd, size %zd, "
-                         "guest hdr len %zd, host hdr len %zd",
-                         i, n->mergeable_rx_bufs,
-                         offset, size, n->guest_hdr_len, n->host_hdr_len);
-#endif
+            virtqueue_discard(q->rx_vq, &elem, total);
             return size;
         }
 
Index: qemu-2.0.0+dfsg/hw/virtio/virtio.c
===================================================================
--- qemu-2.0.0+dfsg.orig/hw/virtio/virtio.c	2015-12-01 16:00:51.324389271 -0500
+++ qemu-2.0.0+dfsg/hw/virtio/virtio.c	2015-12-01 16:00:51.308389127 -0500
@@ -235,14 +235,12 @@
     return vring_avail_idx(vq) == vq->last_avail_idx;
 }
 
-void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
-                    unsigned int len, unsigned int idx)
+static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
+                               unsigned int len)
 {
     unsigned int offset;
     int i;
 
-    trace_virtqueue_fill(vq, elem, len, idx);
-
     offset = 0;
     for (i = 0; i < elem->in_num; i++) {
         size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
@@ -258,6 +256,21 @@
         cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                   elem->out_sg[i].iov_len,
                                   0, elem->out_sg[i].iov_len);
+}
+
+void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,
+                       unsigned int len)
+{
+    vq->last_avail_idx--;
+    virtqueue_unmap_sg(vq, elem, len);
+}
+
+void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
+                    unsigned int len, unsigned int idx)
+{
+    trace_virtqueue_fill(vq, elem, len, idx);
+
+    virtqueue_unmap_sg(vq, elem, len);
 
     idx = (idx + vring_used_idx(vq)) % vq->vring.num;
 
Index: qemu-2.0.0+dfsg/include/hw/virtio/virtio.h
===================================================================
--- qemu-2.0.0+dfsg.orig/include/hw/virtio/virtio.h	2015-12-01 16:00:51.324389271 -0500
+++ qemu-2.0.0+dfsg/include/hw/virtio/virtio.h	2015-12-01 16:00:51.324389271 -0500
@@ -168,6 +168,8 @@
 void virtqueue_push(VirtQueue *vq, const VirtQueueElement *elem,
                     unsigned int len);
 void virtqueue_flush(VirtQueue *vq, unsigned int count);
+void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,
+                       unsigned int len);
 void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
                     unsigned int len, unsigned int idx);
 
